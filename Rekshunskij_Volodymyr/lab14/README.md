## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій



### Звіт про виконання лабораторної роботи №14
# "Принципи проєктування програмного забезпечення"



| Виконав: студент групи ІТ-31 Рекшинський Володимир |
|----------------------------------------------------|
| **Перевірив: Татомир А. В.**                       |



**Мета: познайомитися з найбільш поширеними сучасними принципами
проєктування програмного забезпечення.**


Завдання

1. Дати загальний опис принципів проєктування.
2. Дати детальний опис одного із принципів SOLID з наведенням 
прикладу коду.

**Опис принципів проектування**

Принципи проєктування — це набір рекомендацій і стандартів, які допомагають створювати ефективні, надійні та зручні для використання системи. Вони стосуються організації коду, структури програм, взаємодії між компонентами, а також забезпечення високої якості проєкту в цілому.

Принцип єдиного обов'язку SRP (Single Responsibility Principle): Кожен клас або модуль повинен мати лише одну причину для змін.Кожен компонент повинен відповідати лише за одну частину функціональності системи.

Принцип відкритості/закритості OCP (Open/Closed Principle): Компоненти програмного забезпечення повинні бути відкритими для розширення, але закритими для модифікацій.Потрібно проектувати систему таким чином, щоб додавання нової функціональності не змінювало існуючий код.

Принцип підстановки Лісков LSP (Liskov Substitution Principle): Об'єкти підкласів повинні бути замінними з об'єктами базового класу без порушення коректності програми. Іншими словами, підкласи повинні зберігати поведінку базового класу.

Принцип розділення інтерфейсу ISP (Interface Segregation Principle): Клієнти не повинні залежати від інтерфейсів, які вони не використовують. Краще створювати кілька специфічних інтерфейсів, ніж один великий.

Принцип інверсії залежностей DIP (Dependency Inversion Principle): Вищі модулі не повинні залежати від нижчих, обидва повинні залежати від абстракцій. Абстракції не повинні залежати від деталей, а деталі повинні залежати від абстракцій.

Принцип найменшого подиву (Principle of Least Astonishment): Користувач або інший розробник не повинні бути здивовані поведінкою системи. Програма має бути інтуїтивно зрозумілою та передбачуваною.

Принцип повторного використання (DRY — Don't Repeat Yourself): Кожну частину логіки програмного забезпечення слід реалізовувати тільки один раз, щоб уникнути дублювання коду. Це дозволяє зменшити обсяг змін при коригуванні помилок або додаванні нової функціональності.

Принцип простоти (KISS — Keep It Simple, Stupid): Програмне забезпечення повинно бути якомога простішим, щоб його було легше розуміти, тестувати та підтримувати.

Принцип мінімального зв'язку (Loosely Coupled Design): Модулі повинні бути слабо зв'язаними, щоб зміни в одному компоненті не впливали на інші. Це забезпечує більшу гнучкість та спрощує модифікацію системи.

Принцип високої зрозумілості (Clarity): Код повинен бути легким для розуміння і підтримки. Використання зрозумілих імен змінних, класів і методів, коментарів та документації сприяє високій зрозумілості.



**Опис [коду](./payroll_calculator.py)**


Принципи SOLID є основоположними для створення чистого, гнучкого та масштабованого коду. 

Принцип відкритості/закритості (OCP)
Код має бути відкритим для розширення, але закритим для модифікації. Це означає, що нову функціональність можна додавати без зміни вже існуючого коду, щоб уникнути виникнення багів у робочій системі.

Реалізація: Замість зміни існуючих класів, функцій або модулів, ми створюємо нові класи чи методи, що реалізують нову функціональність. Для досягнення цього часто використовуються інтерфейси, абстрактні класи та принципи поліморфізму.

Наприклад  у нас є система для розрахунку зарплат співробітників. Є різні типи працівників: постійні співробітники, підрядники тощо.Нам потрібно додати новий тип співробітників.

Порушення OCP: Якщо ми додаємо новий тип співробітників і модифікуємо існуючий код, це порушує принцип відкритості/закритості.Додавання нового типу працівника змусить нас змінювати метод calculate_salary, що може призвести до помилок і ускладнює тестування.

Клас PayrollCalculator: який розраховує заробітну плату співробітника, в залежності від типу співробітника (employee_type).
Якщо постійний співробітник (full_time), то зарплата розраховується як hours_worked * 20.
Якщо підрядник (contractor), то розрахунок hours_worked * 15.
Якщо передано інший тип співробітника, з'являється помилка: ValueError("Unknown employee type").


Абстрактний клас Employee базовий клас для всіх типів співробітників.
calculate_salary використовується для розрахунку зарплати працівника в залежності від типу працівника.

Клас FullTimeEmployee наслідує клас Employee і реалізує метод calculate_salary.(зарплата розраховується за ставкою 20 за годину роботи)
Клас Contractor також наслідує клас Employee і реалізує метод calculate_salary.(15 за годину роботи)
Клас Intern наслідує клас Employee і реалізує метод calculate_salary.(становить 10 за годину роботи)

Порушення OCP: Якщо ми хочемо додати новий тип співробітника (наприклад, стажера), потрібно змінювати сам клас PayrollCalculator, додаючи нові умови в метод calculate_salary. Це порушує принцип відкритості/закритості, адже ми змінюємо код при додаванні нового типу.

Переваги дотримання OCP:
Легкість у розширенні: Щоб додати новий тип співробітника, ми створюємо новий клас і не змінюємо існуючий код.
Зменшення ризику помилок: Ми не торкаємося стабільного робочого коду.
Зручність тестування: Кожен новий клас можна тестувати окремо.

## Висновки. 
Ми навчились важливості принципів проектування, зокрема SOLID, для створення гнучких і масштабованих систем. 
Зрозуміли, як принцип відкритості/закритості (OCP) дозволяє додавати нову функціональність без змін в існуючому коді, що знижує ризик помилок і спрощує тестування. 
