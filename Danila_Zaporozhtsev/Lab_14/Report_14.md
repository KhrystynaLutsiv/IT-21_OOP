## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій


### Звіт про виконання лабораторної роботи №14

# "Принципи проєктування програмного забезпечення"


|Виконав: студент групи ІТ-31 Запорожцев Данило|
|----------------------------------------------|
|Перевірив: Татомир Андрій Володимирович|

**Мета: познайомитися з найбільш поширеними сучасними принципами проєктування програмного забезпечення.**

### **Принципи порєктування**

Принцип DRY (Don't Repeat Yourself)
Не дублюйте код. Повторювану логіку варто виносити в окремі модулі або методи.

Принцип KISS (Keep It Simple, Stupid)
Робіть код і архітектуру максимально простими, уникаючи зайвої складності.

Принцип YAGNI (You Aren't Gonna Need It)
Не варто розробляти функціонал, який поки не потрібен.

Принцип інверсії управління (Inversion of Control, IoC)
Взаємодія між компонентами має будуватися через абстракції, наприклад, використовуючи Dependency Injection.

### **Принципи SOLID**

S -  SRP  (Принцип єдиної відповідальності): Об'єкт повинен мати лише одну причину зміни.

O -  OCP  (Принцип відкритості/закритості): Програмні сутності повинні бути відкриті для розширення, але закриті для модифікації.

L -  LSP  (Принцип підстановки Барбари Лісков): Об'єкти в програмі повинні бути замінені на екземпляри їх підтипів без зміни правильності виконання програми.

I -  ISP  (Принцип поділу інтерфейсу): Клієнти не повинні залежати від методів, які вони не використовують.

D -  DIP  (Принцип інверсії залежностей): Залежності всередині системи будуються з урахуванням абстракцій.

### **Принцип відкритості/закритості (Open/Closed Principle)**
Принцип стверджує, що модулі, класи чи функції повинні:
Бути відкритими для розширення: нова поведінка або функціональність може бути додана без значної зміни вже існуючого коду.
Бути закритими для змін: вже існуючий код не повинен змінюватися при додаванні нової функціональності.

Це дозволяє уникнути непередбачених помилок у вже працюючих частинах програми, зберігаючи стабільність і полегшуючи підтримку.

Принцип можна реалізувати за допомогою абстракції методу і поліморфізму.
``` py
class Shape(ABC):
    @abstractmethod
    def calculate_area(self):
        pass
```
Замість зміни існуючого класу, створюється новий клас, що успадковує або реалізує базовий функціонал, і додає нову поведінку.
``` py
class Rectangle(Shape):
    ...
    def calculate_area(self):
        return self.width * self.height
```
``` py
class Circle(Shape):
    ...
    def calculate_area(self):
        return 3.14 * self.radius ** 2
```

Посилання на повний код:

[Лабораторна робота 14](./O.py)

## Висновки. 

 Під час виконання лабораторної роботи я ознайомився з принципами проєктування програмного забезпечення, а також принципами SOLID. Більш ретельно розібрав сутність принципу відкритості/закритості (Open/Closed Principle), написавши невеличку програму для демонстрації цього принципу.
