## Львівський Національний Університет Природокористування
## Кафедра Інформаційних систем та Технологій



### Звіт про виконання лабораторної роботи №13
# "Поведінкові шаблони проектування"



| Виконав: студент групи ІТ-31 кулішов Назар |
|----------------------------------------------------|
| Перевірив: Татомир Андрій Володимирович            |




**Мета: познайомитися з групою поведінкових шаблонів проєктування.**


Завдання

1. Дати теоретичний опис поведінкової групи шаблонів.
2. Відповідно до индивідуального завдання:
- дати теоретичний опис даного шаблону;
- навести приклад коду який реалізовує даний шаблон;
- скласти його UML-діяграму.

Запитання для самоконтролю
1. Що таке поведінкові шаблони?
2. Які поведінкові шаблони Вам відомі?
3. Поясніть як реалізовано шаблон у Вашому прикладі.


Відповіді:
1. Поведінкові шаблони проектування зосереджені на алгоритмах і розподілі відповідальності між об'єктами. Вони описують, як об'єкти взаємодіють і як їх поведінка може змінюватися в залежності від конкретних умов. Метою поведінкових шаблонів є спростити комунікацію між об'єктами, зменшуючи зв'язність і підвищуючи гнучкість системи.

2. Observer: Визначає залежність "один-до-багатьох" між об'єктами, так що при зміні стану одного об'єкта всі його залежні об'єкти отримують повідомлення.

Strategy: Дозволяє визначити сімейство алгоритмів, інкапсулювати їх і дозволити змінювати їх незалежно від клієнтів, які їх використовують.

Command: Інкапсулює запит як об'єкт, що дозволяє параметризувати клієнтів, відкладати виконання та підтримувати скасування.

State: Дозволяє об'єкту змінювати свою поведінку залежно від його стану, при цьому зміна стану змінює поведінку об'єкта.

Template Method: Визначає основу алгоритму в методі, дозволяючи підкласам переоприділити певні кроки алгоритму без зміни його структури.

Iterator: Дозволяє послідовно обходити елементи колекції, не розкриваючи її внутрішню структуру.

Mediator: Визначає об'єкт, який інкапсулює взаємодію між групою об'єктів, зменшуючи зв'язність між ними.

3. У наведеному прикладі реалізації шаблону "State" для моделювання поведінки собак, шаблон реалізований наступним чином:

Основні компоненти шаблону "State"
Інтерфейс DogState:

Це абстрактний клас, що визначає метод behave(), який реалізують всі конкретні стани. Він забезпечує загальний контракт для всіх станів собак.
Конкретні стани:

HungryState, PlayfulState, TiredState: Це конкретні реалізації інтерфейсу DogState. Кожен клас реалізує метод behave(), який описує поведінку собаки в конкретному стані.
HungryState: повідомляє, що собака голодна і потребує їжі.
PlayfulState: вказує, що собака грайлива і готова грати.
TiredState: вказує на те, що собака втомлена і їй потрібен відпочинок.
Клас Dog:

Це основний клас, що представляє собаку. Він має атрибут state, який визначає поточний стан собаки.
Метод act(): викликає метод behave() поточного стану, щоб відобразити поведінку собаки.
Метод set_state(state): дозволяє змінювати стан собаки, передаючи новий об'єкт, що реалізує DogState.
Принципи роботи шаблону "State"
Зміна поведінки: Коли стан собаки змінюється, її поведінка також змінюється. Це реалізується через заміну об'єкта стану в класі Dog. Метод act() завжди викликає behave() поточного стану, тому зміна стану автоматично змінює результати поведінки.

Уникнення складності: Використання шаблону "State" дозволяє уникнути використання великої кількості умовних операторів (if або switch) для управління поведінкою об'єкта. Кожен стан реалізується як окремий клас, що робить код чистішим і легшим для розширення.

Гнучкість і підтримка: Легко додавати нові стани, просто створюючи нові класи, які реалізують інтерфейс DogState. Наприклад, якщо ви хочете додати новий стан "Сонна собака", вам потрібно лише реалізувати новий клас і додати можливість його встановлення в класі Dog.

# UML-Діаграма:
  ```mermaid
 classDiagram
    class Dog {
        - state: DogState
        + set_state(state: DogState): void
        + act(): void
    }

    class DogState {
        <<interface>>
        + behave(): string
    }

    class HungryState {
        + behave(): string
    }

    class PlayfulState {
        + behave(): string
    }

    class TiredState {
        + behave(): string
    }

    DogState <|.. HungryState
    DogState <|.. PlayfulState
    DogState <|.. TiredState
    Dog "1" --> "1" DogState : current state
```
## Висновки. 
На даній лабораторній роботі ми ознайомились з групою поведінкових шаблонів проектування. 


 
